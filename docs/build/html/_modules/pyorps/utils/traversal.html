<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pyorps.utils.traversal &#8212; PYORPS 09.05.2025 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=b08954a9" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=27fed22d" />
    <script src="../../../_static/documentation_options.js?v=d2164c19"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for pyorps.utils.traversal</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numba</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nb</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numba.typed</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dict</span>

<span class="c1"># Define Numba types for clarity</span>
<span class="n">int8_type</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">int8</span>
<span class="n">uint16_type</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">uint16</span>
<span class="n">int32_type</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">int32</span>
<span class="n">uint32_type</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">uint32</span>
<span class="n">float64_type</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">float64</span>
<span class="n">boolean_type</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">boolean</span>

<span class="c1"># Array types - using contiguous arrays for best performance</span>
<span class="n">int8_2d_array</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">int8_type</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="n">uint16_2d_array</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">uint16_type</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="n">uint8_2d_array</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>  <span class="c1"># For exclusion mask</span>
<span class="n">int32_1d_array</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">int32_type</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="n">uint32_1d_array</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">uint32_type</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="n">float64_1d_array</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">float64_type</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="intermediate_steps_numba">
<a class="viewcode-back" href="../../../pyorps.utils.html#pyorps.utils.traversal.intermediate_steps_numba">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">int8_2d_array</span><span class="p">(</span><span class="n">int8_type</span><span class="p">,</span> <span class="n">int8_type</span><span class="p">),</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">intermediate_steps_numba</span><span class="p">(</span><span class="n">dr</span><span class="p">,</span> <span class="n">dc</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;JIT-compiled version of intermediate_steps with direct array manipulation&quot;&quot;&quot;</span>
    <span class="n">abs_dr</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dr</span><span class="p">)</span>
    <span class="n">abs_dc</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dc</span><span class="p">)</span>
    <span class="n">sum_abs</span> <span class="o">=</span> <span class="n">abs_dr</span> <span class="o">+</span> <span class="n">abs_dc</span>

    <span class="c1"># Handle simple cases first for efficiency</span>
    <span class="k">if</span> <span class="n">sum_abs</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>

    <span class="n">k</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">abs_dr</span><span class="p">,</span> <span class="n">abs_dc</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">dr</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">dc</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>

    <span class="c1"># Pre-allocate result array</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>

    <span class="c1"># Manual calculation loop - avoid redundant calculations</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Calculate fractional position</span>
        <span class="n">dr_k</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dr</span> <span class="o">/</span> <span class="n">k</span>
        <span class="n">dc_k</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dc</span> <span class="o">/</span> <span class="n">k</span>

        <span class="c1"># Store floor and ceil values directly</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="n">result</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">dr_k</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">dc_k</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">dr_k</span><span class="p">))</span>
        <span class="n">result</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">dc_k</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="get_cost_factor_numba">
<a class="viewcode-back" href="../../../pyorps.utils.html#pyorps.utils.traversal.get_cost_factor_numba">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">float64_type</span><span class="p">(</span><span class="n">int8_type</span><span class="p">,</span> <span class="n">int8_type</span><span class="p">,</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">),</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_cost_factor_numba</span><span class="p">(</span><span class="n">dr</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">intermediates_count</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;JIT-compiled version of get_cost_factor&quot;&quot;&quot;</span>
    <span class="c1"># Use double precision for intermediate calculation</span>
    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dr</span> <span class="o">*</span> <span class="n">dr</span> <span class="o">+</span> <span class="n">dc</span> <span class="o">*</span> <span class="n">dc</span><span class="p">)</span>
    <span class="n">divisor</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="n">intermediates_count</span>
    <span class="k">return</span> <span class="n">distance</span> <span class="o">/</span> <span class="n">divisor</span></div>



<div class="viewcode-block" id="ravel_index">
<a class="viewcode-back" href="../../../pyorps.utils.html#pyorps.utils.traversal.ravel_index">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">uint32_type</span><span class="p">(</span><span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">),</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">ravel_index</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert 2D indices to 1D linear index - much faster than np.ravel_multi_index&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">uint32_type</span><span class="p">(</span><span class="n">row</span> <span class="o">*</span> <span class="n">cols</span> <span class="o">+</span> <span class="n">col</span><span class="p">)</span></div>



<div class="viewcode-block" id="calculate_region_bounds">
<a class="viewcode-back" href="../../../pyorps.utils.html#pyorps.utils.traversal.calculate_region_bounds">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">uint32_1d_array</span><span class="p">(</span><span class="n">int8_type</span><span class="p">,</span> <span class="n">int8_type</span><span class="p">,</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">),</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_region_bounds</span><span class="p">(</span><span class="n">dr</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate region bounds for source and target regions&quot;&quot;&quot;</span>
    <span class="c1"># Source region bounds</span>
    <span class="k">if</span> <span class="n">dr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">s_rows_start</span><span class="p">,</span> <span class="n">s_rows_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rows</span> <span class="o">-</span> <span class="n">dr</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">s_rows_start</span><span class="p">,</span> <span class="n">s_rows_end</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dr</span><span class="p">)</span> <span class="k">if</span> <span class="n">dr</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rows</span>

    <span class="k">if</span> <span class="n">dc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">s_cols_start</span><span class="p">,</span> <span class="n">s_cols_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cols</span> <span class="o">-</span> <span class="n">dc</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">s_cols_start</span><span class="p">,</span> <span class="n">s_cols_end</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dc</span><span class="p">)</span> <span class="k">if</span> <span class="n">dc</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cols</span>

    <span class="c1"># Target region bounds</span>
    <span class="k">if</span> <span class="n">dr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">t_rows_start</span><span class="p">,</span> <span class="n">t_rows_end</span> <span class="o">=</span> <span class="n">dr</span><span class="p">,</span> <span class="n">rows</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t_rows_start</span><span class="p">,</span> <span class="n">t_rows_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">rows</span> <span class="o">+</span> <span class="n">dr</span> <span class="k">if</span> <span class="n">dr</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">rows</span>

    <span class="k">if</span> <span class="n">dc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">t_cols_start</span><span class="p">,</span> <span class="n">t_cols_end</span> <span class="o">=</span> <span class="n">dc</span><span class="p">,</span> <span class="n">cols</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t_cols_start</span><span class="p">,</span> <span class="n">t_cols_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cols</span> <span class="o">+</span> <span class="n">dc</span> <span class="k">if</span> <span class="n">dc</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">cols</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">s_rows_start</span><span class="p">,</span> <span class="n">s_rows_end</span><span class="p">,</span> <span class="n">s_cols_start</span><span class="p">,</span> <span class="n">s_cols_end</span><span class="p">,</span>
                            <span class="n">t_rows_start</span><span class="p">,</span> <span class="n">t_rows_end</span><span class="p">,</span> <span class="n">t_cols_start</span><span class="p">,</span> <span class="n">t_cols_end</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span></div>



<div class="viewcode-block" id="is_valid_node">
<a class="viewcode-back" href="../../../pyorps.utils.html#pyorps.utils.traversal.is_valid_node">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">boolean_type</span><span class="p">(</span>
    <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span>
    <span class="n">uint8_2d_array</span><span class="p">,</span> <span class="n">int8_2d_array</span><span class="p">,</span> <span class="n">uint16_2d_array</span><span class="p">,</span>
    <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">float64_type</span><span class="p">[:]),</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">is_valid_node</span><span class="p">(</span><span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">,</span> <span class="n">exclude_mask</span><span class="p">,</span> <span class="n">intermediates</span><span class="p">,</span> <span class="n">raster</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">out_cost</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if a node is valid and calculate its cost&quot;&quot;&quot;</span>
    <span class="c1"># Check if source or target coordinates are out of bounds</span>
    <span class="k">if</span> <span class="n">sr</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">sr</span> <span class="o">&gt;=</span> <span class="n">rows</span> <span class="ow">or</span> <span class="n">sc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">sc</span> <span class="o">&gt;=</span> <span class="n">cols</span> <span class="ow">or</span> <span class="n">tr</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">tr</span> <span class="o">&gt;=</span> <span class="n">rows</span> <span class="ow">or</span> <span class="n">tc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">tc</span> <span class="o">&gt;=</span> <span class="n">cols</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Skip if source or target is invalid</span>
    <span class="k">if</span> <span class="n">exclude_mask</span><span class="p">[</span><span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">exclude_mask</span><span class="p">[</span><span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="n">cost</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># Check intermediate points and calculate cost together</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">intermediates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">ir</span> <span class="o">=</span> <span class="n">sr</span> <span class="o">+</span> <span class="n">intermediates</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">ic</span> <span class="o">=</span> <span class="n">sc</span> <span class="o">+</span> <span class="n">intermediates</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Check if intermediate point is valid</span>
        <span class="k">if</span> <span class="n">ir</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ir</span> <span class="o">&gt;=</span> <span class="n">rows</span> <span class="ow">or</span> <span class="n">ic</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ic</span> <span class="o">&gt;=</span> <span class="n">cols</span> <span class="ow">or</span> <span class="n">exclude_mask</span><span class="p">[</span><span class="n">ir</span><span class="p">,</span> <span class="n">ic</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Add intermediate cost</span>
        <span class="n">cost</span> <span class="o">+=</span> <span class="n">raster</span><span class="p">[</span><span class="n">ir</span><span class="p">,</span> <span class="n">ic</span><span class="p">]</span>

    <span class="c1"># Add source and target costs</span>
    <span class="n">cost</span> <span class="o">+=</span> <span class="n">raster</span><span class="p">[</span><span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">]</span> <span class="o">+</span> <span class="n">raster</span><span class="p">[</span><span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">]</span>

    <span class="c1"># Store the cost</span>
    <span class="n">out_cost</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>
    <span class="k">return</span> <span class="kc">True</span></div>



<div class="viewcode-block" id="find_valid_nodes">
<a class="viewcode-back" href="../../../pyorps.utils.html#pyorps.utils.traversal.find_valid_nodes">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">Tuple</span><span class="p">((</span><span class="n">uint32_1d_array</span><span class="p">,</span> <span class="n">uint32_1d_array</span><span class="p">,</span> <span class="n">float64_1d_array</span><span class="p">,</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">))</span>
             <span class="p">(</span><span class="n">int8_type</span><span class="p">,</span> <span class="n">int8_type</span><span class="p">,</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span>
              <span class="n">uint8_2d_array</span><span class="p">,</span> <span class="n">uint16_2d_array</span><span class="p">,</span> <span class="n">int8_2d_array</span><span class="p">,</span>
              <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">float64_type</span><span class="p">,</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">intp</span><span class="p">),</span>
         <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">find_valid_nodes</span><span class="p">(</span><span class="n">dr</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">s_rows_start</span><span class="p">,</span> <span class="n">s_rows_end</span><span class="p">,</span> <span class="n">s_cols_start</span><span class="p">,</span> <span class="n">s_cols_end</span><span class="p">,</span>
                     <span class="n">exclude_mask</span><span class="p">,</span> <span class="n">raster</span><span class="p">,</span> <span class="n">intermediates</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">cost_factor</span><span class="p">,</span> <span class="n">max_nodes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find all valid nodes for a step direction&quot;&quot;&quot;</span>
    <span class="c1"># Pre-allocate arrays - using uint32 directly for linear indices</span>
    <span class="n">max_valid_nodes</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">s_rows_end</span> <span class="o">-</span> <span class="n">s_rows_start</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">s_cols_end</span> <span class="o">-</span> <span class="n">s_cols_start</span><span class="p">),</span> <span class="n">max_nodes</span><span class="p">)</span>
    <span class="n">from_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_valid_nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
    <span class="n">to_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_valid_nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
    <span class="n">costs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_valid_nodes</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="n">valid_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">cost_temp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">dr_int</span><span class="p">,</span> <span class="n">dc_int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dr</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">dc</span><span class="p">)</span>
    <span class="c1"># Find valid nodes and calculate costs</span>
    <span class="k">for</span> <span class="n">sr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s_rows_start</span><span class="p">,</span> <span class="n">s_rows_end</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">sc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s_cols_start</span><span class="p">,</span> <span class="n">s_cols_end</span><span class="p">):</span>
            <span class="n">tr</span> <span class="o">=</span> <span class="n">sr</span> <span class="o">+</span> <span class="n">dr_int</span>
            <span class="n">tc</span> <span class="o">=</span> <span class="n">sc</span> <span class="o">+</span> <span class="n">dc_int</span>

            <span class="c1"># Check validity and get cost</span>
            <span class="k">if</span> <span class="n">is_valid_node</span><span class="p">(</span><span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">,</span> <span class="n">exclude_mask</span><span class="p">,</span> <span class="n">intermediates</span><span class="p">,</span> <span class="n">raster</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">cost_temp</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">valid_count</span> <span class="o">&lt;</span> <span class="n">max_valid_nodes</span><span class="p">:</span>  <span class="c1"># MUST KEEP THIS CHECK</span>
                    <span class="c1"># Store linear indices directly - avoid array resizing</span>
                    <span class="n">from_nodes</span><span class="p">[</span><span class="n">valid_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">ravel_index</span><span class="p">(</span><span class="n">sr</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">cols</span><span class="p">)</span>
                    <span class="n">to_nodes</span><span class="p">[</span><span class="n">valid_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">ravel_index</span><span class="p">(</span><span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">,</span> <span class="n">cols</span><span class="p">)</span>
                    <span class="n">costs</span><span class="p">[</span><span class="n">valid_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost_temp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">cost_factor</span>
                    <span class="n">valid_count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>

    <span class="c1"># Return only valid entries</span>
    <span class="k">return</span> <span class="n">from_nodes</span><span class="p">[:</span><span class="n">valid_count</span><span class="p">],</span> <span class="n">to_nodes</span><span class="p">[:</span><span class="n">valid_count</span><span class="p">],</span> <span class="n">costs</span><span class="p">[:</span><span class="n">valid_count</span><span class="p">],</span> <span class="n">valid_count</span></div>



<div class="viewcode-block" id="get_max_number_of_edges">
<a class="viewcode-back" href="../../../pyorps.utils.html#pyorps.utils.traversal.get_max_number_of_edges">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">uint32_type</span><span class="p">(</span><span class="n">uint32_type</span><span class="p">,</span> <span class="n">uint32_type</span><span class="p">,</span> <span class="n">int8_2d_array</span><span class="p">),</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_max_number_of_edges</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">steps</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the maximum number of edges defined by a neighborhood and a given raster shape.</span>
<span class="sd">    :param n: The number of rows in the raster.</span>
<span class="sd">    :param m: The number of columns in the raster.</span>
<span class="sd">    :param steps: The set of steps for a neighborhood.</span>
<span class="sd">    :return: The maximum number of edges defined by a neighborhood and a given raster shape.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_nr_of_edges</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">step_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">steps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="n">step_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">dc</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="n">step_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">max_nr_of_edges</span> <span class="o">=</span> <span class="n">max_nr_of_edges</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">uint32_type</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dr</span><span class="p">)))</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">uint32_type</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dc</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">max_nr_of_edges</span></div>



<div class="viewcode-block" id="construct_edges">
<a class="viewcode-back" href="../../../pyorps.utils.html#pyorps.utils.traversal.construct_edges">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">Tuple</span><span class="p">((</span><span class="n">uint32_1d_array</span><span class="p">,</span> <span class="n">uint32_1d_array</span><span class="p">,</span> <span class="n">float64_1d_array</span><span class="p">))</span>
             <span class="p">(</span><span class="n">uint16_2d_array</span><span class="p">,</span> <span class="n">int8_2d_array</span><span class="p">,</span> <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">boolean</span><span class="p">),</span>
         <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">construct_edges</span><span class="p">(</span><span class="n">raster</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">ignore_max</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Optimized version using Numba with integer indexing and direct linear indices&quot;&quot;&quot;</span>
    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">nr_of_edges</span> <span class="o">=</span> <span class="n">get_max_number_of_edges</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
    <span class="c1"># Pre-allocate result arrays</span>
    <span class="n">from_nodes_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nr_of_edges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
    <span class="n">to_nodes_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nr_of_edges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
    <span class="n">cost_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nr_of_edges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">last_index</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Find max cost if needed</span>
    <span class="k">if</span> <span class="n">ignore_max</span><span class="p">:</span>
        <span class="n">max_cost</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">raster</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">max_cost</span><span class="p">:</span>
                    <span class="n">max_cost</span> <span class="o">=</span> <span class="n">raster</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">max_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>  <span class="c1"># Max uint16 value</span>

    <span class="c1"># Create exclusion mask using unsigned char (uint8) - more efficient than boolean</span>
    <span class="n">exclude_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
            <span class="n">exclude_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">raster</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">max_cost</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="c1"># Process each step direction</span>
    <span class="k">for</span> <span class="n">step_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">steps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="n">step_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">dc</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="n">step_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Get intermediate steps</span>
        <span class="n">intermediates</span> <span class="o">=</span> <span class="n">intermediate_steps_numba</span><span class="p">(</span><span class="n">dr</span><span class="p">,</span> <span class="n">dc</span><span class="p">)</span>

        <span class="c1"># Calculate region bounds</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="n">calculate_region_bounds</span><span class="p">(</span><span class="n">dr</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)</span>
        <span class="n">s_rows_start</span><span class="p">,</span> <span class="n">s_rows_end</span><span class="p">,</span> <span class="n">s_cols_start</span><span class="p">,</span> <span class="n">s_cols_end</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>

        <span class="c1"># Get cost factor</span>
        <span class="n">cost_factor</span> <span class="o">=</span> <span class="n">get_cost_factor_numba</span><span class="p">(</span><span class="n">dr</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">intermediates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Calculate remaining capacity</span>
        <span class="n">remaining</span> <span class="o">=</span> <span class="n">nr_of_edges</span> <span class="o">-</span> <span class="n">last_index</span>

        <span class="c1"># Find valid nodes - direct use of linear indices</span>
        <span class="n">from_nodes</span><span class="p">,</span> <span class="n">to_nodes</span><span class="p">,</span> <span class="n">costs</span><span class="p">,</span> <span class="n">valid_count</span> <span class="o">=</span> <span class="n">find_valid_nodes</span><span class="p">(</span>
            <span class="n">dr</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">s_rows_start</span><span class="p">,</span> <span class="n">s_rows_end</span><span class="p">,</span> <span class="n">s_cols_start</span><span class="p">,</span> <span class="n">s_cols_end</span><span class="p">,</span>
            <span class="n">exclude_mask</span><span class="p">,</span> <span class="n">raster</span><span class="p">,</span> <span class="n">intermediates</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">cost_factor</span><span class="p">,</span> <span class="n">remaining</span><span class="p">)</span>

        <span class="c1"># If any valid nodes found, copy to result arrays</span>
        <span class="k">if</span> <span class="n">valid_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Calculate end index</span>
            <span class="n">end_idx</span> <span class="o">=</span> <span class="n">last_index</span> <span class="o">+</span> <span class="n">valid_count</span>

            <span class="c1"># Copy in bulk - much faster than looping</span>
            <span class="n">from_nodes_edges</span><span class="p">[</span><span class="n">last_index</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">from_nodes</span>
            <span class="n">to_nodes_edges</span><span class="p">[</span><span class="n">last_index</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">to_nodes</span>
            <span class="n">cost_edges</span><span class="p">[</span><span class="n">last_index</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">costs</span>

            <span class="c1"># Update index</span>
            <span class="n">last_index</span> <span class="o">=</span> <span class="n">end_idx</span>

    <span class="c1"># Return slices up to the valid count</span>
    <span class="k">return</span> <span class="n">from_nodes_edges</span><span class="p">[:</span><span class="n">last_index</span><span class="p">],</span> <span class="n">to_nodes_edges</span><span class="p">[:</span><span class="n">last_index</span><span class="p">],</span> <span class="n">cost_edges</span><span class="p">[:</span><span class="n">last_index</span><span class="p">]</span></div>



<div class="viewcode-block" id="calculate_segment_length">
<a class="viewcode-back" href="../../../pyorps.utils.html#pyorps.utils.traversal.calculate_segment_length">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_segment_length</span><span class="p">(</span><span class="n">abs_dr</span><span class="p">,</span> <span class="n">abs_dc</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the length of a segment based on absolute differences in rows and columns.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">abs_dr</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">abs_dc</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1.4142135623730951</span> <span class="k">if</span> <span class="p">(</span><span class="n">abs_dr</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">abs_dc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="mf">1.0</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">abs_dr</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">abs_dc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">abs_dr</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">abs_dc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">2.236067977499789</span>  <span class="c1"># sqrt(5)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">abs_dr</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">abs_dc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">abs_dr</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">abs_dc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">3.1622776601683795</span>  <span class="c1"># sqrt(10)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">abs_dr</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">abs_dc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">abs_dr</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">abs_dc</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">return</span> <span class="mf">3.605551275463989</span>  <span class="c1"># sqrt(13)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">abs_dr</span> <span class="o">*</span> <span class="n">abs_dr</span> <span class="o">+</span> <span class="n">abs_dc</span> <span class="o">*</span> <span class="n">abs_dc</span><span class="p">)</span></div>



<div class="viewcode-block" id="calculate_path_metrics_numba">
<a class="viewcode-back" href="../../../pyorps.utils.html#pyorps.utils.traversal.calculate_path_metrics_numba">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span>
    <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">Tuple</span><span class="p">((</span><span class="n">float64_type</span><span class="p">,</span>
                    <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">uint16_type</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">),</span>
                    <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">float64_type</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">)))(</span>
        <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">uint16_type</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">),</span>
        <span class="n">nb</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">Array</span><span class="p">(</span><span class="n">uint32_type</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">)</span>
    <span class="p">),</span>
    <span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">calculate_path_metrics_numba</span><span class="p">(</span><span class="n">raster</span><span class="p">,</span> <span class="n">path_indices</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate metrics about the path including total length and length through each cost category.&quot;&quot;&quot;</span>
    <span class="c1"># Get raster dimensions</span>
    <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Number of segments in the path</span>
    <span class="n">n_segments</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_indices</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Convert 1D indices to 2D (row, col)</span>
    <span class="n">path_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">path_indices</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nb</span><span class="o">.</span><span class="n">prange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path_indices</span><span class="p">)):</span>
        <span class="n">path_2d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">path_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">//</span> <span class="n">cols</span>  <span class="c1"># Row</span>
        <span class="n">path_2d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">path_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">%</span> <span class="n">cols</span>  <span class="c1"># Col</span>

    <span class="c1"># Get unique values and sort them</span>
    <span class="n">categories_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">raster</span><span class="p">))</span>
    <span class="n">num_categories</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">categories_array</span><span class="p">)</span>

    <span class="c1"># Find min and max categories to create a compact mapping</span>
    <span class="n">min_category</span> <span class="o">=</span> <span class="n">categories_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">max_category</span> <span class="o">=</span> <span class="n">categories_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">range_size</span> <span class="o">=</span> <span class="n">max_category</span> <span class="o">-</span> <span class="n">min_category</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Create a mapping array that only spans from min_category to max_category</span>
    <span class="c1"># Initialize with -1 to indicate invalid categories</span>
    <span class="n">category_to_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">range_size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="c1"># Fill the mapping array</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_categories</span><span class="p">):</span>
        <span class="n">category_to_index</span><span class="p">[</span><span class="n">categories_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">min_category</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="c1"># Create thread-local arrays to avoid race conditions</span>
    <span class="c1"># Each thread will have its own copy of the lengths array</span>
    <span class="n">num_threads</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">get_num_threads</span><span class="p">()</span>
    <span class="n">thread_local_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_threads</span><span class="p">,</span> <span class="n">num_categories</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">thread_local_total_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_threads</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="c1"># Process each segment in the path in parallel</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nb</span><span class="o">.</span><span class="n">prange</span><span class="p">(</span><span class="n">n_segments</span><span class="p">):</span>
        <span class="c1"># Get the thread ID to use thread-local storage</span>
        <span class="n">thread_id</span> <span class="o">=</span> <span class="n">nb</span><span class="o">.</span><span class="n">get_thread_id</span><span class="p">()</span>

        <span class="n">row</span><span class="p">,</span> <span class="n">col</span> <span class="o">=</span> <span class="n">path_2d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">path_2d</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">next_row</span><span class="p">,</span> <span class="n">next_col</span> <span class="o">=</span> <span class="n">path_2d</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">path_2d</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Calculate deltas</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="n">next_row</span> <span class="o">-</span> <span class="n">row</span>
        <span class="n">dc</span> <span class="o">=</span> <span class="n">next_col</span> <span class="o">-</span> <span class="n">col</span>
        <span class="n">abs_dr</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dr</span><span class="p">)</span>
        <span class="n">abs_dc</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dc</span><span class="p">)</span>

        <span class="c1"># Calculate segment length using the helper function</span>
        <span class="n">segment_length</span> <span class="o">=</span> <span class="n">calculate_segment_length</span><span class="p">(</span><span class="n">abs_dr</span><span class="p">,</span> <span class="n">abs_dc</span><span class="p">)</span>
        <span class="n">thread_local_total_lengths</span><span class="p">[</span><span class="n">thread_id</span><span class="p">]</span> <span class="o">+=</span> <span class="n">segment_length</span>

        <span class="c1"># Get intermediate cells using intermediate_steps_numba</span>
        <span class="n">intermediates</span> <span class="o">=</span> <span class="n">intermediate_steps_numba</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">(</span><span class="n">dr</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">(</span><span class="n">dc</span><span class="p">))</span>

        <span class="c1"># Create a list of all cells including source, target, and intermediates</span>
        <span class="n">all_cells</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">intermediates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

        <span class="c1"># Add source cell</span>
        <span class="n">all_cells</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span>
        <span class="n">all_cells</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span>

        <span class="c1"># Add intermediate cells</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">intermediates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">all_cells</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">row</span> <span class="o">+</span> <span class="n">intermediates</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">all_cells</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span> <span class="o">+</span> <span class="n">intermediates</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Add target cell</span>
        <span class="n">all_cells</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_row</span>
        <span class="n">all_cells</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_col</span>

        <span class="c1"># Distribute segment length among cells</span>
        <span class="n">cell_length</span> <span class="o">=</span> <span class="n">segment_length</span> <span class="o">/</span> <span class="n">all_cells</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Allocate length to categories</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">all_cells</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">all_cells</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">all_cells</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">rows</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">cols</span><span class="p">:</span>
                <span class="n">category</span> <span class="o">=</span> <span class="n">raster</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">]</span>

                <span class="c1"># Only access the mapping array if the category is in range</span>
                <span class="k">if</span> <span class="n">min_category</span> <span class="o">&lt;=</span> <span class="n">category</span> <span class="o">&lt;=</span> <span class="n">max_category</span><span class="p">:</span>
                    <span class="n">map_idx</span> <span class="o">=</span> <span class="n">category</span> <span class="o">-</span> <span class="n">min_category</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">category_to_index</span><span class="p">[</span><span class="n">map_idx</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Verify the index is valid</span>
                        <span class="n">thread_local_lengths</span><span class="p">[</span><span class="n">thread_id</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cell_length</span>

    <span class="c1"># Combine results from all threads</span>
    <span class="n">total_length</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_threads</span><span class="p">):</span>
        <span class="n">total_length</span> <span class="o">+=</span> <span class="n">thread_local_total_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="c1"># Sum up lengths from all threads</span>
    <span class="n">lengths_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_categories</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_threads</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_categories</span><span class="p">):</span>
            <span class="n">lengths_array</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">thread_local_lengths</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">total_length</span><span class="p">,</span> <span class="n">categories_array</span><span class="p">,</span> <span class="n">lengths_array</span></div>



<div class="viewcode-block" id="euclidean_distances_numba">
<a class="viewcode-back" href="../../../pyorps.utils.html#pyorps.utils.traversal.euclidean_distances_numba">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">fastmath</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">euclidean_distances_numba</span><span class="p">(</span><span class="n">raster</span><span class="p">,</span> <span class="n">target_point</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Numba-accelerated function to calculate Euclidean distances from all points to a target point.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_points</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_points</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="c1"># Specialized case for 2D points (common case)</span>
    <span class="k">if</span> <span class="n">raster</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nb</span><span class="o">.</span><span class="n">prange</span><span class="p">(</span><span class="n">n_points</span><span class="p">):</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">raster</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">target_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">raster</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">target_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">dx</span> <span class="o">*</span> <span class="n">dx</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">dy</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># General case for any number of dimensions</span>
        <span class="n">n_dims</span> <span class="o">=</span> <span class="n">raster</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nb</span><span class="o">.</span><span class="n">prange</span><span class="p">(</span><span class="n">n_points</span><span class="p">):</span>
            <span class="n">squared_dist</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dims</span><span class="p">):</span>
                <span class="n">diff</span> <span class="o">=</span> <span class="n">raster</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">target_point</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">squared_dist</span> <span class="o">+=</span> <span class="n">diff</span> <span class="o">*</span> <span class="n">diff</span>
            <span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">squared_dist</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">distances</span></div>



<div class="viewcode-block" id="get_outgoing_edges">
<a class="viewcode-back" href="../../../pyorps.utils.html#pyorps.utils.traversal.get_outgoing_edges">[docs]</a>
<span class="nd">@nb</span><span class="o">.</span><span class="n">njit</span><span class="p">(</span><span class="n">cache</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_outgoing_edges</span><span class="p">(</span><span class="n">node_idx</span><span class="p">,</span> <span class="n">raster</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">exclude_mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get outgoing edges from a specific node only when needed&quot;&quot;&quot;</span>
    <span class="c1"># Convert linear index to 2D coordinates</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">node_idx</span> <span class="o">//</span> <span class="n">cols</span>
    <span class="n">col</span> <span class="o">=</span> <span class="n">node_idx</span> <span class="o">%</span> <span class="n">cols</span>

    <span class="c1"># Prepare result arrays</span>
    <span class="n">max_edges</span> <span class="o">=</span> <span class="n">steps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Maximum possible outgoing edges</span>
    <span class="n">to_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_edges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
    <span class="n">costs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_edges</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">edge_count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Create exclude mask if not provided</span>
    <span class="k">if</span> <span class="n">exclude_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">exclude_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
        <span class="n">max_cost</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cols</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">raster</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">max_cost</span><span class="p">:</span>
                    <span class="n">exclude_mask</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Process each possible step</span>
    <span class="k">for</span> <span class="n">step_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">steps</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">dr</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="n">step_idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">dc</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="n">step_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Calculate target coordinates</span>
        <span class="n">tr</span> <span class="o">=</span> <span class="n">row</span> <span class="o">+</span> <span class="n">dr</span>
        <span class="n">tc</span> <span class="o">=</span> <span class="n">col</span> <span class="o">+</span> <span class="n">dc</span>

        <span class="c1"># Check if target is within bounds</span>
        <span class="k">if</span> <span class="n">tr</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">tr</span> <span class="o">&gt;=</span> <span class="n">rows</span> <span class="ow">or</span> <span class="n">tc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">tc</span> <span class="o">&gt;=</span> <span class="n">cols</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Check if target is valid</span>
        <span class="k">if</span> <span class="n">exclude_mask</span><span class="p">[</span><span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Get intermediate steps</span>
        <span class="n">intermediates</span> <span class="o">=</span> <span class="n">intermediate_steps_numba</span><span class="p">(</span><span class="n">dr</span><span class="p">,</span> <span class="n">dc</span><span class="p">)</span>

        <span class="c1"># Check if all intermediate cells are valid</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">raster</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span>  <span class="c1"># Start with source cost</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">intermediates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">ir</span> <span class="o">=</span> <span class="n">row</span> <span class="o">+</span> <span class="n">intermediates</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">ic</span> <span class="o">=</span> <span class="n">col</span> <span class="o">+</span> <span class="n">intermediates</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">ir</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ir</span> <span class="o">&gt;=</span> <span class="n">rows</span> <span class="ow">or</span> <span class="n">ic</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ic</span> <span class="o">&gt;=</span> <span class="n">cols</span> <span class="ow">or</span> <span class="n">exclude_mask</span><span class="p">[</span><span class="n">ir</span><span class="p">,</span> <span class="n">ic</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>

            <span class="n">cost</span> <span class="o">+=</span> <span class="n">raster</span><span class="p">[</span><span class="n">ir</span><span class="p">,</span> <span class="n">ic</span><span class="p">]</span>  <span class="c1"># Add intermediate cost</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Add target cost</span>
        <span class="n">cost</span> <span class="o">+=</span> <span class="n">raster</span><span class="p">[</span><span class="n">tr</span><span class="p">,</span> <span class="n">tc</span><span class="p">]</span>

        <span class="c1"># Calculate cost factor</span>
        <span class="n">cost_factor</span> <span class="o">=</span> <span class="n">get_cost_factor_numba</span><span class="p">(</span><span class="n">dr</span><span class="p">,</span> <span class="n">dc</span><span class="p">,</span> <span class="n">intermediates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Add edge to result arrays</span>
        <span class="n">to_nodes</span><span class="p">[</span><span class="n">edge_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">tr</span> <span class="o">*</span> <span class="n">cols</span> <span class="o">+</span> <span class="n">tc</span>  <span class="c1"># Linear index of target</span>
        <span class="n">costs</span><span class="p">[</span><span class="n">edge_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span> <span class="o">*</span> <span class="n">cost_factor</span>
        <span class="n">edge_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">to_nodes</span><span class="p">[:</span><span class="n">edge_count</span><span class="p">],</span> <span class="n">costs</span><span class="p">[:</span><span class="n">edge_count</span><span class="p">]</span></div>



</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">PYORPS</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Martin Hofmann.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.2.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>